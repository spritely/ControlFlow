// --------------------------------------------------------------------------------------------------------------------
// <copyright file="RetryableActionTest.cs">
//   Copyright (c) 2016. All rights reserved.
//   Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Spritely.Redo source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Redo.Test
{
    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using FluentAssertions;
    using NUnit.Framework;

    [TestFixture]
    public class RetryableActionTest
    {
        [Test]
        public void Now_does_not_delay_when_first_execution_succeeds()
        {
            var called = false;
            var retryableOperation = new BackoffStrategy(
                _ =>
                {
                    called = true;
                    return TimeSpan.FromSeconds(10);
                }).Run(() => { });

            var stopWatch = Stopwatch.StartNew();
            retryableOperation.Now();
            stopWatch.Stop();

            stopWatch.Elapsed.Should().BeLessThan(TimeSpan.FromMilliseconds(200));
            called.Should().BeFalse();
        }

        [Test]
        public void Now_retries_up_to_specified_max_retries()
        {
            var maxRetries = 13;
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .WithMaxRetries(maxRetries)
                .Run(() =>
                    {
                        times++;
                        throw new InvalidOperationException();
                    });

            Assert.Throws<InvalidOperationException>(() => retryableOperation.Now());
            times.Should().Be(maxRetries + 1); // Initial call and maxRetries retry attempts
        }

        [Test]
        public void Now_calls_reporter_with_each_failure()
        {
            var retries = 4;
            var times = 0;
            var called = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .WithReporter(
                    ex =>
                    {
                        called++;
                        ex.Should().BeOfType<InvalidOperationException>();
                        ex.Message.Should().Be(times.ToString());
                    })
                .Run(() =>
                {
                    times++;

                    if (times > retries)
                    {
                        return;
                    }

                    throw new InvalidOperationException(times.ToString());
                });

            retryableOperation.Now();
            called.Should().Be(retries);
        }

        [Test]
        public void Now_retries_on_all_exceptions_when_unspecified()
        {
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .Run(() =>
                {
                    times++;

                    switch (times)
                    {
                        case 1:
                            throw new InconclusiveException("Test");
                        case 2:
                            throw new InvalidOperationException();
                    }
                });

            retryableOperation.Now();
            times.Should().Be(3);
        }

        [Test]
        public void Now_only_retries_specified_exceptions_when_any_specified()
        {
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .RetryOn<InconclusiveException>()
                .RetryOn<InvalidOperationException>()
                .Run(() =>
                {
                    times++;

                    switch (times)
                    {
                        case 1:
                            throw new InconclusiveException("Test");
                        case 2:
                            throw new InvalidOperationException();
                    }

                    throw new ArgumentException();
                });

            Assert.Throws<ArgumentException>(() => retryableOperation.Now());
            times.Should().Be(3);
        }

        [Test]
        public void Now_throws_when_encountering_an_unhandleable_exception()
        {
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .ThrowOn<ArgumentException>()
                .Run(() =>
                {
                    times++;

                    switch (times)
                    {
                        case 1:
                            throw new InconclusiveException("Test");
                        case 2:
                            throw new InvalidOperationException();
                    }

                    throw new ArgumentException();
                });

            Assert.Throws<ArgumentException>(() => retryableOperation.Now());
            times.Should().Be(3);
        }

        [Test]
        public void Now_throws_when_encountering_any_unhandleable_exception()
        {
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .ThrowOn<ArgumentException>()
                .ThrowOn<AccessViolationException>()
                .Run(() =>
                {
                    times++;

                    switch (times)
                    {
                        case 1:
                            throw new InconclusiveException("Test");
                        case 2:
                            throw new InvalidOperationException();
                        case 3:
                            throw new AccessViolationException();
                    }

                    throw new ArgumentException();
                });

            Assert.Throws<AccessViolationException>(() => retryableOperation.Now());
            times.Should().Be(3);
        }

        [Test]
        public void Now_gives_priority_to_unhandleable_exception_over_handleable_exception()
        {
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .ThrowOn<ArgumentException>()
                .ThrowOn<AccessViolationException>()
                .RetryOn<InconclusiveException>()
                .RetryOn<InvalidOperationException>()
                .RetryOn<AccessViolationException>()
                .Run(() =>
                {
                    times++;

                    switch (times)
                    {
                        case 1:
                            throw new InconclusiveException("Test");
                        case 2:
                            throw new InvalidOperationException();
                        case 3:
                            throw new AccessViolationException();
                    }

                    throw new ArgumentException();
                });

            Assert.Throws<AccessViolationException>(() => retryableOperation.Now());
            times.Should().Be(3);
        }

        [Test]
        public void Constructor_throws_on_invalid_arguments()
        {
            Func<long, TimeSpan> getDelay = _ => TimeSpan.Zero;
            var maxRetries = 5;
            Action<Exception> report = _ => { };
            var exceptionsToRetry = new List<Type>();
            var exceptionsToThrow = new List<Type>();
            Action operation = () => { };

            Assert.Throws<ArgumentNullException>(() => new RetryableAction(null, maxRetries, report, exceptionsToRetry, exceptionsToThrow, operation));
            Assert.Throws<ArgumentOutOfRangeException>(() => new RetryableAction(getDelay, 0, report, exceptionsToRetry, exceptionsToThrow, operation));
            Assert.Throws<ArgumentOutOfRangeException>(() => new RetryableAction(getDelay, -1, report, exceptionsToRetry, exceptionsToThrow, operation));
            Assert.Throws<ArgumentNullException>(() => new RetryableAction(getDelay, maxRetries, null, exceptionsToRetry, exceptionsToThrow, operation));
            Assert.Throws<ArgumentNullException>(() => new RetryableAction(getDelay, maxRetries, report, null, exceptionsToThrow, operation));
            Assert.Throws<ArgumentNullException>(() => new RetryableAction(getDelay, maxRetries, report, exceptionsToRetry, null, operation));
            Assert.Throws<ArgumentNullException>(() => new RetryableAction(getDelay, maxRetries, report, exceptionsToRetry, exceptionsToThrow, null));
        }

        [Test]
        public void Until_throws_on_null_argument()
        {
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .Run(() => { });
            
            Assert.Throws<ArgumentNullException>(() => retryableOperation.Until(null));
        }

        [Test]
        public void Now_calls_Until_up_to_max_retries_when_until_does_not_become_valid()
        {
            var maxRetries = 6;
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .WithMaxRetries(maxRetries)
                .Run(() => { })
                .Until(
                    () =>
                    {
                        times++;
                        return false;
                    });

            Assert.Throws<TimeoutException>(() => retryableOperation.Now());
            times.Should().Be(maxRetries + 1); // Initial call and maxRetries retry attempts
        }

        [Test]
        public void Now_finishes_when_Until_becomes_valid()
        {
            var retries = 8;
            var times = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .Run(() => { })
                .Until(
                    () =>
                    {
                        times++;
                        return times == retries;
                    });

            retryableOperation.Now();
            times.Should().Be(retries);
        }

        [Test]
        public void Now_finishes_when_any_Until_becomes_valid()
        {
            var retries1 = 7;
            var retries2 = 2;
            var times1 = 0;
            var times2 = 0;
            var retryableOperation = Using.ConstantBackoff(TimeSpan.FromMilliseconds(10))
                .Run(() => { })
                .Until(
                    () =>
                    {
                        times1++;
                        return times1 == retries1;
                    })
                .Until(
                    () =>
                    {
                        times2++;
                        return times2 == retries2;
                    });

            retryableOperation.Now();
            times1.Should().Be(retries2);
            times2.Should().Be(retries2);
        }
    }
}
