// --------------------------------------------------------------------------------------------------------------------
// <copyright file="BackoffStrategy.cs">
//   Copyright (c) 2016. All rights reserved.
//   Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Spritely.Redo source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Redo
{
    using System;
    using System.Collections.Generic;
    using System.Threading.Tasks;

    /// <summary>
    ///     Main interface for building up the backoff strategy before entering the operation context
    ///     for running retryable operations.
    /// </summary>
#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal partial class BackoffStrategy
    {
        private readonly Func<long, TimeSpan> getDelay;
        private readonly ICollection<Type> exceptionsToRetryOn = new List<Type>();
        private readonly ICollection<Type> exceptionsToThrowOn = new List<Type>();
        private long maxRetries = long.MaxValue;
        private Action<Exception> report = ex => { };

        /// <summary>
        /// Initializes a new instance of the <see cref="BackoffStrategy"/> class.
        /// </summary>
        /// <param name="getDelay">The function that determines the next delay given the current attempt number - the backoff strategy.</param>
        public BackoffStrategy(Func<long, TimeSpan> getDelay)
        {
            if (getDelay == null)
            {
                throw new ArgumentNullException("getDelay");
            }

            this.getDelay = getDelay;
        }

        /// <summary>
        /// Sets the maximum number of retries to perform the operation before giving up and throwing.
        /// </summary>
        /// <param name="maxRetries">The maximum number of retries to perform the operation before giving up and throwing.</param>
        /// <returns>
        /// This instance for chaining.
        /// </returns>
        public BackoffStrategy WithMaxRetries(long maxRetries)
        {
            if (maxRetries < 1)
            {
                throw new ArgumentOutOfRangeException("maxRetries", maxRetries, "Value must be at least 1.");
            }

            this.maxRetries = maxRetries;

            return this;
        }

        /// <summary>
        /// Sets the function that reports on any exceptions as they occur (even if they are handled).
        /// </summary>
        /// <param name="report">The function that reports on any exceptions as they occur (even if they are handled).</param>
        /// <returns>
        /// This instance for chaining.
        /// </returns>
        public BackoffStrategy WithReporter(Action<Exception> report)
        {
            if (report == null)
            {
                throw new ArgumentNullException("report");
            }

            this.report = report;

            return this;
        }

        /// <summary>
        /// Adds an exception to retry operations on. If none are provided then Exception
        /// will be caught, but if one or more are provided then only they will be caught.
        /// </summary>
        /// <typeparam name="TException">The type of the exception to retry on.</typeparam>
        /// <returns>This instance for chaining.</returns>
        public BackoffStrategy RetryOn<TException>() where TException : Exception
        {
            exceptionsToRetryOn.Add(typeof(TException));

            return this;
        }

        /// <summary>
        /// Adds an exception that should always throw if encountered.
        /// </summary>
        /// <typeparam name="TException">The type of the exception to throw on.</typeparam>
        /// <returns>This instance for chaining.</returns>
        public BackoffStrategy ThrowOn<TException>() where TException : Exception
        {
            exceptionsToThrowOn.Add(typeof(TException));

            return this;
        }

        /// <summary>
        /// Runs the specified operation.
        /// </summary>
        /// <param name="operation">The operation to execute and retry as needed.</param>
        /// <returns>A retryable function context.</returns>
        public RetryableAction Run(Action operation)
        {
            if (operation == null)
            {
                throw new ArgumentNullException("operation");
            }

            return new RetryableAction(getDelay, maxRetries, report, exceptionsToRetryOn, exceptionsToThrowOn, operation);
        }

        /// <summary>
        /// Runs the specified operation.
        /// </summary>
        /// <param name="operation">The operation to execute and retry as needed.</param>
        /// <returns>A retryable function context.</returns>
        public RetryableActionAsync RunAsync(Func<Task> operation)
        {
            if (operation == null)
            {
                throw new ArgumentNullException("operation");
            }

            return new RetryableActionAsync(getDelay, maxRetries, report, exceptionsToRetryOn, exceptionsToThrowOn, operation);
        }

        /// <summary>
        /// Runs the specified operation.
        /// </summary>
        /// <typeparam name="T">The type of result returned from the operation.</typeparam>
        /// <param name="operation">The operation to execute and retry as needed.</param>
        /// <returns>A retryable function context.</returns>
        public RetryableFunction<T> Run<T>(Func<T> operation)
        {
            if (operation == null)
            {
                throw new ArgumentNullException("operation");
            }

            return new RetryableFunction<T>(getDelay, maxRetries, report, exceptionsToRetryOn, exceptionsToThrowOn, operation);
        }

        /// <summary>
        /// Runs the specified asyncronous operation
        /// </summary>
        /// <typeparam name="T">The type of result returned from the operation.</typeparam>
        /// <param name="operation">The operation to execute and retry as needed.</param>
        /// <returns>A retryable function context.</returns>
        public RetryableFunctionAsync<T> RunAsync<T>(Func<Task<T>> operation)
        {
            if (operation == null)
            {
                throw new ArgumentNullException("operation");
            }

            return new RetryableFunctionAsync<T>(getDelay, maxRetries, report, exceptionsToRetryOn, exceptionsToThrowOn, operation);
        }
    }
#if !SpritelyRecipesProject
#pragma warning restore 0436
#endif
}
