// --------------------------------------------------------------------------------------------------------------------
// <copyright file="SafeDelay.cs">
//   Copyright (c) 2016. All rights reserved.
//   Licensed under the MIT license. See LICENSE file in the project root for full license information.
// </copyright>
// <auto-generated>
//   Sourced from NuGet package. Will be overwritten with package update except in Spritely.Redo source.
// </auto-generated>
// --------------------------------------------------------------------------------------------------------------------

namespace Spritely.Redo.Internal
{
    using System;

#if !SpritelyRecipesProject
    [System.Diagnostics.DebuggerStepThrough]
    [System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
    [System.CodeDom.Compiler.GeneratedCode("Spritely.Recipes", "See package version number")]
#pragma warning disable 0436
#endif
    internal class SafeDelay
    {
        public static TimeSpan CalculateConstantDelaySleepTime(TimeSpan delay)
        {
            var sleepTime = TimeSpan.FromMilliseconds(Math.Max(1, delay.TotalMilliseconds));

            return sleepTime;
        }

        public static TimeSpan CalculateExponentialDelaySleepTime(long attempt, TimeSpan delay, double scaleFactor)
        {
            var factor = Math.Pow(scaleFactor, (attempt - 1));
            var safefactor = (factor < 1) ? 1 : factor;
            var totalDelay = delay.TotalMilliseconds * safefactor;

            var sleepTime = ConstrainBounds(totalDelay);

            return sleepTime;
        }

        public static TimeSpan CalculateLinearDelaySleepTime(long attempt, TimeSpan delay, double scaleFactor)
        {
            var factor = ((attempt - 1) * scaleFactor);
            var safefactor = (factor < 0) ? 0 : factor;
            var totalDelay = delay.TotalMilliseconds + safefactor;

            var sleepTime = ConstrainBounds(totalDelay);

            return sleepTime;
        }

        public static TimeSpan CalculateProgressiveDelaySleepTime(long attempt, TimeSpan delay, double scaleFactor)
        {
            var factor = ((attempt - 1) * scaleFactor);
            var safefactor = (factor < 1) ? 1 : factor;
            var totalDelay = delay.TotalMilliseconds * safefactor;

            var sleepTime = ConstrainBounds(totalDelay);

            return sleepTime;
        }

        public static TimeSpan ConstrainBounds(double delay, double minimumBounds = 1,
            double maximumBounds = Double.MaxValue)
        {
            if (minimumBounds > maximumBounds)
            {
                throw new ArgumentException("minimumBounds cannot be greater than maximumBounds");
            }

            TimeSpan boundedTimeSpan;
            try
            {
                boundedTimeSpan = TimeSpan.FromMilliseconds(delay);
            }
            catch (OverflowException)
            {
                boundedTimeSpan = TimeSpan.MaxValue;
            }

            var lowBounded = Math.Max(minimumBounds, boundedTimeSpan.TotalMilliseconds);
            var bounded = Math.Min(maximumBounds, lowBounded);

            // This throws overflow exception: TimeSpan.FromMilliseconds(TimeSpan.MaxValue.TotalMilliseconds);
            // Therefore, must first construct the max value differently
            if (Math.Abs(TimeSpan.MaxValue.TotalMilliseconds - bounded) < 0.1)
            {
                return TimeSpan.MaxValue;
            }

            boundedTimeSpan = TimeSpan.FromMilliseconds(bounded);

            return boundedTimeSpan;
        }
    }
#if !SpritelyRecipesProject
#pragma warning restore 0436
#endif
}
